#summary NAM4J first tutorial.

= Introduction =

No NAM4J binary release is currently available, but you can get the source code from svn.

Folder src/ contains the middleware, that includes 5 packages:
{{{
it.unipr.ce.dsg.nam4j.interfaces
it.unipr.ce.dsg.nam4j.impl
it.unipr.ce.dsg.nam4j.impl.context
it.unipr.ce.dsg.nam4j.impl.resource
it.unipr.ce.dsg.nam4j.impl.service
}}}

Folder examples/ contains demo code. Details are given below.


= demonam =
This folder contains the code that implements a NAM. There is a unique class

{{{
DemoNam extends NetworkedAutonomicMachine
}}}

The constructor instantiates three functional modules: 

{{{
cfm = new ChordFunctionalModule(this);
this.addFunctionalModule(cfm);
rfm = new ReasonerFunctionalModule(this);
this.addFunctionalModule(rfm);
sfm = new SensorFunctionalModule(this);
this.addFunctionalModule(sfm);
}}}

whose details are given in the following sections.
In the {{{main()}}} method, {{{DemoNam}}} randomly starts either a publication process (using its sensorfm) or a lookup process (using its reasonerfm).


= sensorfm =
This folder contains the code that implements a functional module that simulates a temperature sensor. There are two classes. The main one is

{{{
SensorFunctionalModule extends FunctionalModule
}}}

exposing the method {{{startTemperatureNotificationProcess()}}}, that once called detaches a thread that runs an instance of

{{{
ProvideTemperatureRunnable implements Runnable
}}}

Such a class implements the functional logic of the sensorfm. Its {{{run()}}} method looks for a {{{Publish}}} service within those exposed by the functional modules of the NAM. Then it creates a context event (instance of {{{TemperatureNotification}}}), turns it into a JSON message, and publish the latter using the {{{Publish}}} service.  


= reasonerfm =
This folder contains the code that implements a functional module that acts as a reasoner. There are two classes. The main one is

{{{
ReasonerFunctionalModule extends FunctionalModule
}}}

exposing the methods

{{{
subscribeToTemperatureNotifications()
startTemperatureNotificationLookupProcess()
}}}

The first method looks for a {{{Subscribe}}} service within those exposed by the functional modules of the NAM. If such a service is found, it is used to subscribe to instances of {{{TemperatureNotification}}} context events that may be published within the network.

The second method detaches a thread that runs an instance of

{{{
LookupRunnable implements Runnable
}}}

Its {{{run()}}} method looks for a {{{Lookup}}} service within those exposed by the functional modules of the NAM. If such a a service is found, it is used to search for the latest instance of {{{TemperatureNotification}}} context event that may have been published within the network.


= chordfm =
This folder contains the code that implements a functional module that provides Chord-based overlay functionalities. It is based on a Chord implementation that uses *Sip2Peer* as networking middleware.

There are three classes. the main one is

{{{
ChordFunctionalModule extends FunctionalModule implements ChordEventListener
}}}

that provides the following services:

{{{
Lookup lookupService = new Lookup();
Notify notifyService = new Notify();
Publish publishService = new Publish();
Subscribe subscribeService = new Subscribe();
}}}

When one these services is called, a thread is detached, executing the code implemented in the following classes:

{{{
LookupRunnable implements Runnable (to be fixed)
NotifyRunnable implements Runnable (TODO)
PublishRunnable implements Runnable (to be fixed)
SubscribeRunnable implements Runnable (TODO)
}}}

= ontology = 
This folder contains the code that implements the domain ontology of the demo. The following classes have been implemented:

{{{
Lookup (extends Service)
Notify (extends Service)
Publish (extends service)
Room (extends Parameter)
Subscribe (extends Service)
Temperature (extends Parameter)
temperatureNotification (describes a context event)
}}}